# 벡터( 1차원 데이터 , 원소의 묶음 / 문자는 "" 사용)
s <- c(1,2,3,4,5,6)
s2 <- c(1:6)         # 시작:끝
s3 <- c(6:1)
s4 <- 1:5
c(1:3, c(1:6)) # 벡터로 묶었을때 (1 ~ 6, 1,2,3) 이 아닌 각 벡터의 순서대로 1 ~ 3 , 1 ~ 6으로 묶임을 알 수 있다.
c(1:30)
seq(1, 100, by=2) # from, to , increment by = 숫자간의 간격 설정
seq(from=100, to=1, by=-3)
seq(0, 1, by=0.1)
seq(0, 1, length.out=11) # 0 ~ 1 까지 범위에서 (length.out)11개 엘리먼트 길이의 수열을 만들어줘

rep(c(1:3), times=2) # 1 2 3 1 2 3 / 1 ~ 3까지의 범위로 2번 반복해줘
rep(c(1:3), each=2)  # 1 1 2 2 3 3 / 1 ~ 3까지의 범위인데 각각의 원소를 두번 반복해줘
rep(c(1:3), times=c(1,2,3)) # 1은 1번 2는 2번 3은 3번 반복이 된다.

# 숫자형 벡터와 문자형 벡터를 묶으면
num <- c(1:3)
cha <- c("x","z",'y')
c(num, cha) # 숫자도 문자형으로 바뀌면서 문자형 벡터로 바뀜


# 인덱싱
x <- seq(2,10,by=2) # 2 ~ 10 까지의 범위에서 2 간격인 수열 
x[1] # []는 묶음 혹은 수열에서 [n]번째의 원소를 나타냄.
x[-1] # 첫 번째 원소를 제외한다.
x[-3] # 세 번째 원소를 제외한다.

#slicing
x[1:3] # 2, 3, 6
x[c(1,3,5)] # 벡터를 제외한 [1,3,5] 커맨드가 안먹힘, 필요한 엘리먼트만 뽑기 위해 벡터를 사용  
x[-c(2,4)] 

# 연산
x <- c(1:4)
y <- c(5:8)
z <- c(3,4)
w <- c(5:7)

x + 2 # 3 4 5 6  
x + y # 6 8 10 12
x + z # 4 6 6 8 길이가 짧은 z가 남은 엘리먼트에 한 번씩 더 추가됨. 
x + w # 6 8 10 9

length(w) # 해당 변수의 묶음 또는 수열의 개수 표현

x > 2 # x <- c(1:4)
all(x>2) # AND 조건에 맞지 않는 1이 포함되어 있어 F
any(x>2) # OR 조건에 맞는 2,3,4 중 하나만 있어도 T

# fancy indexing
str(x)
str(y)
y[x>2] 

x <- 1:10
head(x)
head(x, 3)
tail(x,3)

# 집합 연산
x <- 1:3
y <- 3:5
z <- c(3,1,2)

union(x, y)    #합집합(중복 없이)
intersect(x,y) #교집합
setdiff(x, y)  #차집합 x - y
setdiff(y, x)  #       y - x
setequal(x, y) # F 두 집합이 같아? 
setequal(x, z) # T 두 집합에 원소 순서 상관없이 똑같으면 T


